"""
=======================
The HTML (TOKEN) Parser
=======================

Take generated tokens list, run validation checks and convert into nodes that represent each HTML tag.
"""

from __future__ import annotations

from .lexer import Cursor, TokenTypes, Lexer, Token

from dataclasses import dataclass


@dataclass
class HTMLOpeningTagNode:
    """
    Represents an opening HTML tag.
    """
    tag_name: str
    attributes: dict
    inner_html: str
    cursor_start: Cursor
    cursor_end: Cursor


@dataclass
class HTMLSelfClosingTagNode:
    """
    Represents a self closing HTML tag.
    """
    tag_name: str
    attributes: dict
    cursor_start: Cursor
    cursor_end: Cursor


@dataclass
class HTMLClosingTagNode:
    """
    Represents a closing HTML tag.
    """
    tag_name: str
    cursor_start: Cursor
    cursor_end: Cursor


@dataclass
class HTMLDoctypeOrCommNode:
    """
    Represents other HTML tags such as comments and doctype declarations.
    """
    text_raw: str
    cursor_start: Cursor
    cursor_end: Cursor


class NonValidTagIDError(Exception): ...
class NeverEndedTagError(Exception): ...


@dataclass
class HTMLErrorNode:
    """
    Represents an erroneous HTML tag (if validation rules fail during parse for valid tags).
    """
    message: str
    cursor_start: Cursor
    cursor_end: Cursor
    exception: Exception


class Parser:
    """
    Used to a parse stream (str/ bytes) of HTML code into valid nodes/ error nodes. First uses lexer module to create
    tokens list and then runs :meth:``self._parse_tokens_to_node_list`` to parse into a list of nodes.  

    -------------
    Example Usage
    -------------

    ::

        with open("basic.html", "r") as htmlfile:
            stream = htmlfile.read()

        parser = Parser(stream)

        import pprint  # More readable prints of final node list.
        pretty = pprint.PrettyPrinter(indent=4)
        pretty.pprint(parser._parse_tokens_to_node_list())

    """
    def __init__(self, html: str | bytes) -> None:
        assert type(html) == bytes or type(html) == str, "HTML Stream must be bytes string or string"
        self.__html_stream = html.decode("utf-8") if type(html) == bytes else html
        self.__html_raw = html
        self.__lexer = Lexer(html)
        self.__lexed = self.__lexer.lex()
        self.__index = 0
        self.__tags_list = []

    @property
    def html_raw(self) -> str:
        """
        The original unprocessed stream of HTML code.
        """
        return self.__html_raw

    @property
    def lexer(self) -> str:
        """
        The parser's lexer object.
        """
        return self.__lexer

    @property
    def lexed(self) -> list:
        """
        The list of tokens generated by lexing the HTML code stream passed to the parser.
        """
        return self.__lexed

    @property
    def tag_nodes_list(self) -> list:
        """
        The list of tag/ error nodes generated from the ``self._parse_tokens_to_node_list`` method.
        """
        return self.__tags_list

    @property
    def curr_token(self) -> Token:
        """
        The current token in the list.
        """
        return self.lexed[self.__index]

    @property
    def __next_token(self) -> Token:
        """
        **For internal use only**
        
        Return current token in the list and then move to the next one.
        """
        self.__index += 1 if self.__index < len(self.lexed) - 1 else 0
        return self.lexed[self.__index]

    def _parse_tokens_to_node_list(self, *, debug: bool=False) -> list:
        """
        Converts tokens into HTML node classes.

        --------
        Supports
        --------

        ::
        - Opening tags                               =>   ``<html>``
        - Opening tags (w attrs/ multi attrs)        =>   ``<html lang="en">``
        - Self closing tags                          =>   ``<img/>``
        - Self closing tags (w attrs/ multi attrs)   =>   ``<img src="null" alt="an example"/>``
        - Closing tags                               =>   ``</html>``

        Any thing that does not match this criteria will instead be stored as an error node (or will be ignored if
        possible and does not impact main structure of the tag), with a message as to what error was encountered and a
        start and end cursor to be used in a verbose print of error nodes at some point.

        :return: ``self.__tags_list``, the list where nodes were stored after the node parse process is complete.
        :rtype: list
        """
        while self.curr_token.type is not TokenTypes.EOF:
            # Opened tag.
            if self.curr_token.type is TokenTypes.ANGLE_BRACKET_L:
                start_cursor = self.curr_token.cursor

                if self.__next_token.type not in [TokenTypes.ID,
                                                  TokenTypes.EXCLAMATION,
                                                  TokenTypes.CLOSING_SLASH]: # ERROR NODE: non-valid tag.
                    tag = HTMLErrorNode(message=f"Invalid tag name/ ID '{self.curr_token.value}'",
                                        cursor_start=start_cursor,
                                        cursor_end=self.curr_token.cursor,
                                        exception=NonValidTagIDError(f"Invalid tag name/ ID '{self.curr_token.value}'"))
                    self.__tags_list.append(tag)
                    continue

                tag = HTMLOpeningTagNode(tag_name=self.curr_token.value,
                                         attributes=None,
                                         inner_html=None,  # To be generated at a later stage.
                                         cursor_start=start_cursor,
                                         cursor_end=None)

                # Process and validate closing tags.
                if self.curr_token.type is TokenTypes.CLOSING_SLASH:
                    end = Cursor(self.curr_token.cursor.index, self.curr_token.cursor.line, self.curr_token.cursor.col)
                    tok = Token(self.curr_token.type, self.curr_token.value, self.curr_token.cursor)
                    if self.__next_token.type is not TokenTypes.ID: # ERROR NODE: no id for closing tag.
                        tag = HTMLErrorNode(message=f"Invalid tag name/ ID '{tok.value}'",
                                            cursor_start=start_cursor,
                                            cursor_end=end,
                                            exception=NonValidTagIDError(f"Invalid tag name/ ID '{tok.value}'"))
                        self.__tags_list.append(tag)
                        continue
                    tag = HTMLClosingTagNode(tag_name=self.curr_token.value,
                                             cursor_start=start_cursor,
                                             cursor_end=None)
                elif self.curr_token.type is TokenTypes.EXCLAMATION:
                    tag = HTMLDoctypeOrCommNode(text_raw=self.curr_token.extra,
                                                cursor_start=start_cursor,
                                                cursor_end=None)

                # Process and validate attrs if it is an open tag, not a closing tag.
                if self.__next_token.type is TokenTypes.ID: 
                    attrs = {}
                    while ...:
                        if self.curr_token.type is not TokenTypes.ID: break
                        key = self.curr_token.value
                        if self.__next_token.type is not TokenTypes.ASSIGNMENT: break
                        if self.__next_token.type is not TokenTypes.QUOTE: break
                        value = self.curr_token.value
                        attrs[key] = value
                        self.__next_token
                    tag.attributes = attrs

                # Process and validate the end brace of any tag.
                if self.curr_token.type is TokenTypes.CLOSING_SLASH: # Convert to selfclosing if ends w '/>'.
                    if self.__next_token.type is not TokenTypes.ANGLE_BRACKET_R:  # ERROR NODE: not closed w '>'.
                        tag = HTMLErrorNode(message="Tag was never ended using a '>' bracket",
                                            cursor_start=start_cursor,
                                            cursor_end=self.curr_token.cursor,
                                            exception=NeverEndedTagError("Tag was never ended using a '>' bracket"))
                        self.__tags_list.append(tag)
                        continue
                    tag = HTMLSelfClosingTagNode(tag_name=tag.tag_name,
                                                 attributes=tag.attributes,
                                                 cursor_start=tag.cursor_start,
                                                 cursor_end=None)
                elif self.curr_token.type is not TokenTypes.ANGLE_BRACKET_R:  # ERROR NODE: not closed w '>'.
                    tag = HTMLErrorNode(message="Tag was never ended using a '>' bracket",
                                        cursor_start=start_cursor,
                                        cursor_end=self.curr_token.cursor,
                                        exception=NeverEndedTagError("Tag was never ended using a '>' bracket"))
                    self.__tags_list.append(tag)
                    continue

                tag.cursor_end = self.curr_token.cursor
                self.__tags_list.append(tag)

            else:  # Not starting with '<' so not a tag. Continue to next token.
                self.__next_token

        self._generate_nodes_content()  # Generate content for each node corrosponding with ending tag.

        return self.__tags_list

    def _generate_nodes_content(self) -> None:
        """
        Match open and closing tags as pairs and return their inner HTML using string slices on the original raw HTML
        that was passed to the parser.

        Stack checking for accurate pairing ::

                _________________________________________________
              v|(5)                                        v|(5) |
            [<div>,  <p>,  <p>,  </p>,  <p>,  </p>,  </div>]     |
               ^|    ^|    ^|     ^|    ^|     ^|                |
             (1)|  (2)|  (3)|___(3)/  (4)|___(4)/                |
              Push  Push  Push   |          |                    |
                                 | Pop <----| <------------------/
                                 V
                            [ (n1, n2) , ... ] 

                # If the node is an opening tag, push to the stack,
                # else if it is a closing tag and matches the tag that is at the end of the stack
                # pop the last item on the stack and pair it with the current closing tag node.
                # Repeat until all pairs are found.

        In the above diagram, the value (2) would not be paired and would be ignored as it is not valid HTML.
        """
        node_pairs = []  # Store matching valid pairs (tuples)
        stack = []  # A stack to store opening tags.

        for node in self.__tags_list:
            if type(node) == HTMLOpeningTagNode:
                stack.append(node)
            elif type(node) == HTMLClosingTagNode:
                for index, _ in enumerate(stack):
                    if index < len(stack): index += 1  # Add 1 to the index, avoid mismatches due to -0 index.
                    else: break  # Save a trailing cycle on each operation.
                    if stack[-index].tag_name == node.tag_name:
                        node_pairs.append((stack.pop(-index), node))
                        break  # Exit after the first matching pair have been found on stack, avoid mismatches.

        for pair in node_pairs:
            pair[0].inner_html = self.html_raw[pair[0].cursor_end.index + 1 : pair[1].cursor_start.index]
