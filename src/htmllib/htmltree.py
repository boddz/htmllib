"""
==========================
HTMLLIB HTMLTree Interface
==========================

A (kind of) tree like interface that acts as an API over the parsed HTML nodes generated from the parser.
"""


from .parser import (
    Parser,
    HTMLDoctypeOrCommNode,
    HTMLOpeningTagNode,
    HTMLClosingTagNode,
    HTMLSelfClosingTagNode,
    HTMLErrorNode
)


class HTMLTree:
    def __init__(self, html_stream: str) -> None:
        self.__html_stream = html_stream
        self.__parser_obj = Parser(html_stream)
        self.__nodes_list = self.__parser_obj._parse_tokens_to_node_list()
        self.__doctype_or_comment_nodes = [node for node in self.__nodes_list if type(node) == HTMLDoctypeOrCommNode]
        self.__opening_tag_nodes = [node for node in self.__nodes_list if type(node) == HTMLOpeningTagNode]
        self.__closing_tag_nodes = [node for node in self.__nodes_list if type(node) == HTMLClosingTagNode]
        self.__self_closing_tag_nodes = [node for node in self.__nodes_list if type(node) == HTMLSelfClosingTagNode]
        self.__error_nodes = [node for node in self.__nodes_list if type(node) == HTMLErrorNode]

    @property
    def html_stream(self) -> list:
        """
        The raw HTML stream that was passed to this instance.
        """
        return self.__html_stream

    @property
    def nodes_list(self) -> list:
        """
        The list of nodes that was generated by this instance's parser.
        """
        return self.__nodes_list

    @property
    def doctype_or_comment_nodes(self) -> list:
        return self.__doctype_or_comment_nodes

    @property
    def opening_tag_nodes(self) -> list:
        return self.__opening_tag_nodes

    @property
    def closing_tag_nodes(self) -> list:
        return self.__closing_tag_nodes

    @property
    def self_closing_tag_nodes(self) -> list:
        return self.__self_closing_tag_nodes

    @property
    def error_nodes(self) -> list:
        return self.__error_nodes

    def search_tags_using_attrs(self, attrs: dict) -> list:
        nodes = [node for node in self.opening_tag_nodes if attrs == node.attributes]  # Opening tags with attrs.
        if len(self.self_closing_tag_nodes) > 0:  # Then append self closing tags with attrs if any.
            nodes.append(*[node for node in self.self_closing_tag_nodes if attrs == node.attributes])
        return nodes

    def search_tags_using_exact_attrs(self, attrs: dict) -> list:
        nodes = []
        if len(self.self_closing_tag_nodes) > 0:
            nodes.append(*[node for node in self.self_closing_tag_nodes if attrs == node.attributes])
        attrs = list(attrs.items())
        match_count = 0
        for node in self.opening_tag_nodes:
            try:
                for index, attr in enumerate(node.attributes.items()):
                    if attr[0] != attrs[index][0] and attr[1] != attrs[index][1]: break
                    match_count += 1
            except IndexError:
                continue
            
            if match_count == len(node.attributes): nodes.append(node)

        return nodes

    def search_tags_by_attr(self, attr: tuple) -> list:
        assert attr != () and type(attr) is tuple, "You need to provide a valid dict {'<attr_key>': '<attr_value>'}"
        nodes = [n for n in self.opening_tag_nodes if attr[0] in n.attributes and n.attributes[attr[0]] == attr[1]]
        if len(self.self_closing_tag_nodes) > 0:
            nodes.append(*[n for n in self.opening_tag_nodes if attr[0] in n.attributes and                           \
                           n.attributes[attr[0]] == attr[1]])
        return nodes

    def search_tags_by_id(self, tag_id: str) -> list:
        assert type(tag_id) == str, "You need to provide the ID as a string"
        return self.search_tags_by_attr(("id", tag_id))

    def search_tags_by_class(self, tag_class: str) -> list:
        assert type(tag_class) == str, "You need to provide the ID as a string"
        return self.search_tags_by_attr(("class", tag_class))
