"""
==========================
HTMLLIB HTMLTree Interface
==========================

A (kind of) tree like interface that acts as an API over the parsed HTML nodes generated from the parser.
"""

from __future__ import annotations

from .parser import (
    Parser,
    HTMLDoctypeOrCommNode,
    HTMLOpeningTagNode,
    HTMLClosingTagNode,
    HTMLSelfClosingTagNode,
    HTMLErrorNode
)


class HTMLTree:
    """
    This class acts as the main interface you should use to interact with the parsed HTML data.

    :param html_stream: A stream of raw HTML code to parse
    :type html_stream: bytes, str

    -------------
    Example Usage
    -------------

    ::

        import htmllib

        htmltree = htmllib.HTMLTree('''
            <html lang="en">
                <head>
                    <title>HTMLLIB Test Page</title>
                </head>
                <body>
                    <h1>Hello, World!</h1>
                    <p id="find_me">You found me!</p>
                </body>
            </html>
        ''')

        # Stdout output: You found me!
        print(htmltree.search_tags_by_id("find_me")[0].inner_html)
    """
    def __init__(self, html_stream: str | bytes) -> None:
        assert type(html_stream) == bytes or type(html_stream) == str, "HTML Stream must be bytes string or string"
        self.__html_stream = html_stream.decode("utf-8") if type(html_stream) == bytes else html_stream
        self.__parser_obj = Parser(self.__html_stream)
        self.__nodes_list = self.__parser_obj._parse_tokens_to_node_list()
        self.__doctype_or_comment_nodes = [node for node in self.__nodes_list if type(node) == HTMLDoctypeOrCommNode]
        self.__opening_tag_nodes = [node for node in self.__nodes_list if type(node) == HTMLOpeningTagNode]
        self.__closing_tag_nodes = [node for node in self.__nodes_list if type(node) == HTMLClosingTagNode]
        self.__self_closing_tag_nodes = [node for node in self.__nodes_list if type(node) == HTMLSelfClosingTagNode]
        self.__error_nodes = [node for node in self.__nodes_list if type(node) == HTMLErrorNode]

    @property
    def html_stream(self) -> str:
        """
        The raw HTML stream that was passed to this instance.
        """
        return self.__html_stream

    @property
    def nodes_list(self) -> list:
        """
        The list of nodes that was generated by this instance's parser.
        """
        return self.__nodes_list

    @property
    def doctype_or_comment_nodes(self) -> list:
        """
        All of the doctype/ comment tag nodes generated from parser, referenced in an iscolated list.
        """
        return self.__doctype_or_comment_nodes

    @property
    def doctypes_raw(self) -> list:
        """
        List of all raw doctype declarations found in the HTML as processed strings.
        """
        raw = []
        for node in self.doctype_or_comment_nodes:
            if len(node.text_raw) < 4: continue
            if node.text_raw[:2] == "--" and node.text_raw[2:] == "--": continue
            if "DOCTYPE".casefold() not in node.text_raw.strip()[:7].casefold(): continue
            raw.append(node.text_raw.strip())
        return raw

    @property
    def doctype_raw(self) -> str:
        """
        The most recent doctype declaration.
        """
        return self.doctypes_raw[-1] if len(self.doctypes_raw) > 0 else None

    @property
    def opening_tag_nodes(self) -> list:
        """
        All of the opening tag nodes generated from parser, referenced in an iscolated list.
        """
        return self.__opening_tag_nodes

    @property
    def closing_tag_nodes(self) -> list:
        """
        All of the closing tag nodes generated from parser, referenced in an iscolated list.
        """
        return self.__closing_tag_nodes

    @property
    def self_closing_tag_nodes(self) -> list:
        """
        All of the self closing tag nodes generated from parser, referenced in an iscolated list.
        """
        return self.__self_closing_tag_nodes

    @property
    def error_nodes(self) -> list:
        """
        All of the error nodes generated from parser, referenced in an iscolated list.
        """
        return self.__error_nodes

    def search_tags_by_name(self, name: str, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that match the
        tag name provided.
        """
        assert type(name) == str, "You need to provide the tag name as a string"
        nodes = self.self_closing_tag_nodes if self_closing else self.opening_tag_nodes
        nodes = [node for node in nodes if node.tag_name == name]
        return nodes

    def search_tags_by_attrs(self, attrs: dict, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that match the
        tag attributes provided (non-strict matching, order does not matter).
        """
        assert type(attrs) == dict, "You need to provide the attributes as a dict (can be non-strict order)"
        nodes = self.self_closing_tag_nodes if self_closing else self.opening_tag_nodes
        matched = [node for node in nodes if attrs == node.attributes]
        return matched

    def search_tags_by_exact_attrs(self, attrs: dict, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that match the
        tag attributes provided (strict matching, order does matter).
        """
        assert type(attrs) == dict, "You need to provide the attributes as a dict (must be strict order)"
        nodes = self.self_closing_tag_nodes if self_closing else self.opening_tag_nodes
        matched = []
        attrs = list(attrs.items())

        for node in nodes:
            match_count = 0
            try:
                if node.attributes is None: continue
                for index, attr in enumerate(node.attributes.items()):
                    if attr[0] != attrs[index][0] or attr[1] != attrs[index][1]: break
                    match_count += 1
            except IndexError:
                continue
            if match_count == len(node.attributes) and len(attrs) == len(node.attributes): matched.append(node)

        return matched

    def search_tags_by_attr(self, attr: tuple, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that contain
        the provided attr (<key>, <value>) pair.
        """
        assert attr != () and type(attr) is tuple, "You need to provide a valid tuple ('<attr_key>', '<attr_value>')"
        nodes = self.self_closing_tag_nodes if self_closing else self.opening_tag_nodes
        matched = [n for n in nodes if n.attributes is not None and attr[0] in n.attributes and                       \
                   n.attributes[attr[0]] == attr[1]]
        return matched

    def search_tags_by_attrs_keys(self, attrs_keys: list, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that match the
        tag attributes keys provided (non-strict matching, order does not matter).
        """
        assert attrs_keys != [] and type(attrs_keys) is list, "You must provide a valid keys list [<key>, <key>, ...]"
        nodes = self.self_closing_tag_nodes if self_closing else self.opening_tag_nodes
        matched = []
        for node in nodes:
            if node.attributes is None: continue
            match_count = 0
            for attr_key in node.attributes.keys():
                if attr_key not in attrs_keys: break
                match_count += 1
            if match_count == len(node.attributes) and len(attrs_keys) == len(node.attributes): matched.append(node)

        return matched

    def search_tags_by_exact_attrs_keys(self, attrs_keys: list, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that match the
        tag attributes keys provided (strict matching, order does matter).
        """
        assert attrs_keys != [] and type(attrs_keys) is list, "You must provide a valid keys list [<key>, <key>, ...]"
        nodes = self.self_closing_tag_nodes if self_closing else self.opening_tag_nodes
        matched = []

        for node in nodes:
            match_count = 0
            try:
                if node.attributes is None: continue
                for index, attr_key in enumerate(node.attributes.keys()):
                    if attr_key != attrs_keys[index]: break
                    match_count += 1
            except IndexError:
                continue
            if match_count == len(node.attributes) and len(attrs_keys) == len(node.attributes): matched.append(node)

        return matched

    def search_tags_by_attr_key(self, attr_key: str, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that contain
        the provided attr key.
        """
        assert attr_key != () and type(attr_key) is str, "You need to provide a valid str <attr_key>)"
        nodes = self.self_closing_tag_nodes if self_closing else self.opening_tag_nodes
        matched = [n for n in nodes if n.attributes is not None and attr_key in n.attributes]
        return matched

    def search_tags_by_id(self, tag_id: str, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that contain
        the provided ID value. This is a shortcut method to ``self.search_tags_by_attr``.
        """
        assert type(tag_id) == str, "You need to provide the ID as a string"
        return self.search_tags_by_attr(("id", tag_id), self_closing=self_closing)

    def search_tags_by_class(self, tag_class: str, *, self_closing: bool=False) -> list:
        """
        Search through opening tags node list (or self closing if specified) and return a list of nodes that contain
        the provided class value. This is a shortcut method to ``self.search_tags_by_attr``.
        """
        assert type(tag_class) == str, "You need to provide the class as a string"
        return self.search_tags_by_attr(("class", tag_class), self_closing=self_closing)
